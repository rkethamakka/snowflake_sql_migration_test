{
  "permissions": {
    "allow": [
      "Bash(snow sql:*)",
      "Bash(docker exec:*)",
      "Bash(cat:*)",
      "Bash(ls:*)",
      "Bash(echo:*)",
      "Bash(docker stop:*)",
      "Bash(docker rm:*)",
      "Bash(docker run:*)",
      "Bash(migration-plans/usp_ProcessBudgetConsolidation.md << 'PLANEOF'\n# Migration Plan: usp_ProcessBudgetConsolidation\n\n**Generated:** 2026-02-06\n**Source:** `src/StoredProcedures/usp_ProcessBudgetConsolidation.sql`\n**Target:** Snowflake `FINANCIAL_PLANNING.PLANNING` schema\n\n---\n\n## Executive Summary\n\n**Complexity:** COMPLEX \\(510 lines, 2 cursors, dynamic SQL, nested transactions\\)  \n**Approach:** JavaScript stored procedure  \n**Estimated Effort:** 28-39 hours\n\n---\n\n## Dependencies \\(Deployment Order\\)\n\n### Phase 1: Tables \\(6\\)\n\n| Table | Status | Notes |\n|-------|--------|-------|\n| FiscalPeriod | TO_MIGRATE | No dependencies |\n| GLAccount | TO_MIGRATE | Has SPARSE column |\n| CostCenter | TO_MIGRATE | Self-referencing hierarchy |\n| BudgetHeader | TO_MIGRATE | XML→VARIANT conversion |\n| BudgetLineItem | TO_MIGRATE | FK to all above |\n| ConsolidationJournal | TO_MIGRATE | Audit table |\n\n### Phase 2: Functions \\(2\\)\n\n| Function | Type | Status |\n|----------|------|--------|\n| fn_GetHierarchyPath | Scalar | TO_MIGRATE |\n| tvf_ExplodeCostCenterHierarchy | Table-valued | TO_MIGRATE |\n\n### Phase 3: Views \\(1\\)\n\n| View | Status |\n|------|--------|\n| vw_BudgetConsolidationSummary | TO_MIGRATE |\n\n### Phase 4: Procedure \\(1\\)\n\n| Procedure | Complexity | Approach |\n|-----------|------------|----------|\n| usp_ProcessBudgetConsolidation | COMPLEX | JavaScript |\n\n---\n\n## Complexity Analysis\n\n- **Lines:** 510\n- **Cursors:** 2 \\(FAST_FORWARD, SCROLL KEYSET\\)\n- **Table variables:** 3 with indexes\n- **Dynamic SQL:** sp_executesql with OUTPUT\n- **Transactions:** Named savepoints\n- **OUTPUT clauses:** 3\n- **XML:** ExtendedProperties modification\n\n---\n\n## Key Patterns\n\n1. **Hierarchy cursor \\(lines 97-289\\):** Bottom-up traversal → Recursive CTE\n2. **Elimination cursor \\(lines 108-349\\):** SCROLL with RELATIVE/PRIOR → LEAD/LAG windows\n3. **Table variables \\(lines 57-87\\):** @Tables → TEMPORARY TABLES\n4. **Dynamic SQL \\(lines 364-399\\):** sp_executesql → JavaScript strings\n5. **XML \\(lines 181-186, 381-382\\):** XML type → VARIANT/JSON\n\n---\n\n## Snowflake Translation\n\n| SQL Server | Snowflake | Complexity |\n|------------|-----------|------------|\n| CURSOR | JavaScript loop | HIGH |\n| Table variable | TEMP TABLE | MEDIUM |\n| sp_executesql | snowflake.execute\\(\\) | MEDIUM |\n| SAVEPOINT | Restructure | MEDIUM |\n| OUTPUT | RETURNING | LOW |\n| XML | VARIANT/JSON | MEDIUM |\n\n---\n\n## Estimated Effort\n\n| Phase | Hours |\n|-------|-------|\n| Tables \\(6\\) | 6-8 |\n| Functions \\(2\\) | 4-6 |\n| View \\(1\\) | 2-3 |\n| Procedure | 10-14 |\n| Testing | 6-8 |\n| **Total** | **28-39** |\n\n---\n\n## Next Steps\n\n1. `/sql-migration usp_ProcessBudgetConsolidation`\n2. `/test-data-generator usp_ProcessBudgetConsolidation`\n3. `/sql-migration-verify usp_ProcessBudgetConsolidation`\nPLANEOF)",
      "Bash(find:*)",
      "Bash(export PATH=\"$PATH:$HOME/Library/Python/3.9/bin\")",
      "Bash(migration-plans/usp_ProcessBudgetConsolidation.md << 'PLANEOF'\n# Migration Plan: usp_ProcessBudgetConsolidation\n\n**Generated:** 2026-02-06  \n**Source:** `src/StoredProcedures/usp_ProcessBudgetConsolidation.sql`  \n**Target:** Snowflake `FINANCIAL_PLANNING.PLANNING` schema\n\n---\n\n## Executive Summary\n\n**Complexity:** COMPLEX  \n**Lines of Code:** 510  \n**Recommended Approach:** JavaScript stored procedure with temporary tables  \n**Estimated Effort:** 28-39 hours\n\n**Key Challenges:**\n- 2 cursors \\(FAST_FORWARD and SCROLL KEYSET with RELATIVE/PRIOR positioning\\)\n- 3 table variables with indexes\n- Dynamic SQL with sp_executesql and table variable scope\n- Named transaction savepoints \\(SAVE TRANSACTION\\)\n- OUTPUT clauses capturing inserted rows\n- XML processing for ExtendedProperties\n- @@TRANCOUNT, @@ROWCOUNT, @@FETCH_STATUS patterns\n\n---\n\n## Dependencies \\(in order\\)\n\n### Tables \\(6\\)\n\n| Name | Status | Notes |\n|------|--------|-------|\n| FiscalPeriod | TO_MIGRATE | No dependencies, reference data |\n| GLAccount | TO_MIGRATE | Has SPARSE column \\(StatutoryAccountCode\\) |\n| CostCenter | TO_MIGRATE | Self-referencing hierarchy \\(ParentCostCenterID\\) |\n| BudgetHeader | TO_MIGRATE | XML column \\(ExtendedProperties\\) → VARIANT |\n| BudgetLineItem | TO_MIGRATE | Foreign keys to all above tables |\n| ConsolidationJournal | TO_MIGRATE | Audit/logging table |\n\n### Functions \\(2\\)\n\n| Name | Type | Status | Notes |\n|------|------|--------|-------|\n| fn_GetHierarchyPath | Scalar UDF | TO_MIGRATE | Builds hierarchy path string |\n| tvf_ExplodeCostCenterHierarchy | Table-valued | TO_MIGRATE | Called with CROSS APPLY \\(line 218\\) |\n\n### Views \\(1\\)\n\n| Name | Status | Notes |\n|------|--------|-------|\n| vw_BudgetConsolidationSummary | TO_MIGRATE | Depends on tables |\n\n### Procedure \\(1\\)\n\n| Name | Complexity | Approach |\n|------|------------|----------|\n| usp_ProcessBudgetConsolidation | COMPLEX | JavaScript |\n\n---\n\n## Complexity Analysis\n\n**Code Metrics:**\n- Lines: 510\n- Cursors: 2\n  - HierarchyCursor \\(lines 97-100\\): LOCAL FAST_FORWARD READ_ONLY\n  - EliminationCursor \\(lines 108-119\\): LOCAL SCROLL KEYSET, updateable\n- Table variables with indexes: 3\n  - @ProcessingLog \\(lines 57-66\\): IDENTITY, 1 index\n  - @HierarchyNodes \\(lines 68-76\\): 1 index\n  - @ConsolidatedAmounts \\(lines 78-87\\): PRIMARY KEY\n- Dynamic SQL: Yes \\(lines 364-399, sp_executesql with OUTPUT parameters\\)\n- Transaction handling: BEGIN TRY/CATCH, named savepoints \\(lines 201, 301\\)\n- OUTPUT clauses: 3 \\(lines 167, 423-428\\)\n- XML processing: Yes \\(lines 180-186, 381-382\\)\n\n**Complexity Rating:** COMPLEX\n- Multiple cursors with different behaviors \\(FAST_FORWARD vs SCROLL\\)\n- Complex cursor positioning logic \\(FETCH RELATIVE, FETCH PRIOR\\)\n- Table variables referenced in dynamic SQL\n- Business logic: hierarchy rollup + intercompany elimination\n\n---\n\n## Patterns Detected\n\n### 1. **Bottom-Up Hierarchy Cursor** \\(lines 229-286\\)\n\n**Pattern:**\n```sql\nDECLARE HierarchyCursor CURSOR LOCAL FAST_FORWARD READ_ONLY FOR\n    SELECT NodeID, NodeLevel, ParentNodeID\n    FROM @HierarchyNodes\n    ORDER BY NodeLevel DESC, NodeID;  -- Bottom-up\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\n    -- Calculate subtotal for current node\n    -- Add child subtotals \\(already processed\\)\n    -- Update node as processed\n    -- MERGE into consolidated amounts\nEND\n```\n\n**Snowflake Solution:**\n- **Option A \\(Recommended\\):** Recursive CTE for bottom-up aggregation\n- **Option B:** JavaScript procedure with ordered result set iteration\n- **Complexity:** HIGH\n\n---\n\n### 2. **SCROLL Cursor with RELATIVE/PRIOR** \\(lines 303-345\\)\n\n**Pattern:**\n```sql\nDECLARE EliminationCursor CURSOR LOCAL SCROLL KEYSET FOR ...\n\nWHILE @@FETCH_STATUS = 0\nBEGIN\n    FETCH RELATIVE 1 FROM EliminationCursor ...  -- Look ahead\n    IF @@FETCH_STATUS = 0 AND @OffsetAmount = -@ElimAmount\n        -- Found matching pair, eliminate\n    ELSE\n        FETCH PRIOR FROM EliminationCursor ...  -- Move back\n    \n    FETCH NEXT FROM EliminationCursor ...\nEND\n```\n\n**Snowflake Solution:**\n- LEAD/LAG window functions to detect adjacent offsetting entries\n- Self-join pattern with ROW_NUMBER\\(\\)\n- JavaScript array manipulation for complex lookahead/lookback logic\n- **Complexity:** HIGH\n\n---\n\n### 3. **Table Variables with Indexes** \\(lines 57-87\\)\n\n**Pattern:**\n```sql\nDECLARE @ConsolidatedAmounts TABLE \\(\n    GLAccountID INT NOT NULL,\n    ...\n    PRIMARY KEY \\(GLAccountID, CostCenterID, FiscalPeriodID\\)\n\\);\n```\n\n**Snowflake Solution:**\n```sql\nCREATE OR REPLACE TEMPORARY TABLE ConsolidatedAmounts \\(\n    GLAccountID NUMBER\\(38,0\\) NOT NULL,\n    ...\n    PRIMARY KEY \\(GLAccountID, CostCenterID, FiscalPeriodID\\)\n\\);\n```\n- **Complexity:** MEDIUM \\(straightforward translation\\)\n\n---\n\n### 4. **Dynamic SQL with Table Variables** \\(lines 364-399\\)\n\n**Pattern:**\n```sql\nSET @DynamicSQL = N'\n    UPDATE ca\n    SET FinalAmount = ca.ConsolidatedAmount - ca.EliminationAmount\n    FROM @ConsolidatedAmounts ca  -- Table variable in scope!\n    ...\n';\nEXEC sp_executesql @DynamicSQL, @ParamDefinition, @RowCountOUT = @AllocationRowCount OUTPUT;\n```\n\n**Snowflake Solution:**\n- JavaScript with string manipulation for dynamic SQL\n- Use snowflake.execute\\(\\) with temp tables \\(not table variables\\)\n- Track row count via stmt.getNumRowsAffected\\(\\)\n- **Complexity:** MEDIUM\n\n---\n\n### 5. **OUTPUT Clause** \\(lines 167, 423-428\\)\n\n**Pattern:**\n```sql\nINSERT INTO Planning.BudgetHeader \\(...\\)\nOUTPUT inserted.BudgetHeaderID, inserted.BudgetCode INTO @InsertedHeaders\nSELECT ...\n```\n\n**Snowflake Solution:**\n- Use separate query after INSERT to retrieve generated IDs\n- Or use JavaScript with RETURNING clause \\(limited support\\)\n- **Complexity:** LOW\n\n---\n\n### 6. **XML Processing** \\(lines 180-186, 381-382\\)\n\n**Pattern:**\n```sql\n-- XML construction\nCAST\\('<Root>' + ... AS XML\\)\n\n-- XML querying\n@ProcessingOptions.value\\('\\(/Options/IncludeZeroBalances\\)[1]', 'BIT'\\)\n```\n\n**Snowflake Solution:**\n```sql\n-- JSON construction \\(VARIANT type\\)\nOBJECT_CONSTRUCT\\('Root', OBJECT_CONSTRUCT\\(...\\)\\)\n\n-- JSON querying\nGET_PATH\\(processing_options, 'Options.IncludeZeroBalances'\\)::BOOLEAN\n```\n- **Complexity:** MEDIUM\n\n---\n\n## Snowflake Translation Guidelines\n\n### Data Type Mappings\n\n| SQL Server | Snowflake | Notes |\n|------------|-----------|-------|\n| INT | NUMBER\\(38,0\\) | No native INT |\n| BIGINT | NUMBER\\(38,0\\) | Same as INT |\n| DECIMAL\\(19,4\\) | NUMBER\\(19,4\\) | Direct |\n| NVARCHAR\\(MAX\\) | VARCHAR | No length limit |\n| VARCHAR\\(20\\) | VARCHAR\\(20\\) | Direct |\n| BIT | BOOLEAN | Direct |\n| DATETIME2 | TIMESTAMP_NTZ | No timezone |\n| UNIQUEIDENTIFIER | VARCHAR\\(36\\) | Use UUID_STRING\\(\\) |\n| XML | VARIANT | Store as JSON |\n\n### Function Mappings\n\n| SQL Server | Snowflake |\n|------------|-----------|\n| SYSUTCDATETIME\\(\\) | CURRENT_TIMESTAMP\\(\\) |\n| GETDATE\\(\\) | CURRENT_DATE\\(\\) |\n| NEWID\\(\\) | UUID_STRING\\(\\) |\n| FORMAT\\(date, 'yyyyMMdd'\\) | TO_CHAR\\(date, 'YYYYMMDD'\\) |\n| @@ROWCOUNT | stmt.getNumRowsAffected\\(\\) \\(JS\\) |\n| @@TRANCOUNT | Track manually in JavaScript |\n| @@FETCH_STATUS | Use JavaScript while\\(rs.next\\(\\)\\) |\n| ERROR_NUMBER\\(\\) | SQLCODE in exception |\n| ERROR_MESSAGE\\(\\) | SQLERRM in exception |\n\n---\n\n## Estimated Effort\n\n| Phase | Task | Hours |\n|-------|------|-------|\n| **Phase 1** | Migrate 6 tables \\(DDL + indexes + constraints\\) | 6-8 |\n| **Phase 2** | Migrate 2 functions \\(scalar + TVF → JS UDF\\) | 4-6 |\n| **Phase 3** | Migrate 1 view | 2-3 |\n| **Phase 4** | Migrate procedure \\(JavaScript translation\\) | 10-14 |\n| **Testing** | Unit + integration + comparison tests | 6-8 |\n| **Total** | | **28-39 hours** |\n\n---\n\n## Risk Assessment\n\n### High Risk\n1. SCROLL cursor with RELATIVE/PRIOR positioning - no direct equivalent\n2. Table variables in dynamic SQL scope - requires temp tables\n3. Complex cursor logic for elimination matching\n\n### Medium Risk\n1. XML → JSON conversion - different syntax\n2. Named savepoints - limited Snowflake support\n3. Error handling model differences\n\n### Low Risk\n1. Table creation - straightforward conversion\n2. Basic CRUD operations\n3. Scalar function mappings\n\n---\n\n## Testing Strategy\n\n### Unit Tests \\(per dependency\\)\n- Each table: Insert/select/update/delete\n- Each function: Various input parameters\n- Each view: Row count and column validation\n\n### Integration Tests\n1. Hierarchy rollup: Verify parent = sum\\(children\\)\n2. Elimination matching: Verify paired entries eliminated\n3. Allocation calculation: Verify FinalAmount = Consolidated - Elimination\n4. Transaction rollback: Verify partial rollback on error\n\n### Comparison Tests \\(SQL Server vs Snowflake\\)\n- Identical test data loaded to both systems\n- Execute procedure in both\n- Compare:\n  - Return values \\(target ID, rows processed\\)\n  - Row counts in output tables\n  - Amount totals and distributions\n  - Hierarchy subtotals\n\n---\n\n## Next Steps\n\n1. **Execute:** `/sql-migration usp_ProcessBudgetConsolidation`\n2. **Test Data:** `/test-data-generator usp_ProcessBudgetConsolidation`\n3. **Verify:** `/sql-migration-verify usp_ProcessBudgetConsolidation`\n\n**Status:** Ready for migration\nPLANEOF)",
      "Bash(xargs:*)",
      "Bash(done)",
      "Bash(docker cp:*)"
    ]
  }
}
